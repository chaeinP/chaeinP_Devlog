---
title: MySQL_데이터 모델링 실습
date: '2021-11-11'
tags: ['MySQL']
draft: false
summary:
---

> [42 체크인 서비스](https://cluster.42seoul.io/checkin)를 분석하고 이를 토대로 직접 데이터 모델링을 실습한다.

데이터 모델링은 [이전에 학습했던 방법](https://chaeinp.vercel.app/blog/MySQL/06_%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EB%AA%A8%EB%8D%B8%EB%A7%81)을 토대로 실습한다.

핵심만 요약하면 서비스의 비즈니스 룰에서 `명사` 는 entity, 즉 테이블이 될 수 있고 `동사` 는 테이블간의 관계를 설명하며, `하나의 값으로 표현 가능한 명사`는 attribute가 될 수 있다.

## 42 체크인 서비스 룰 분석

- 개포와 서초 클러스터의 총 좌석 수와 현재 사용 중인 좌석 수, 운영시간을 확인할 수 있다.

  - **개포(하나의 값으로 표현 가능한 명사)**, **서초 클러스터(하나의 값으로 표현 가능한 명사)** 의 **총 좌석 수(하나의 값으로 표현 가능한 명사)**, **현재 사용 중인 좌석수(하나의 값으로 표현 가능한 명사)** , **운영시간(하나의 값으로 표현 가능한 명사)**을 **확인할 수 있다.(동사)**

- 유저는 42 OAUTH를 통해 로그인한다.

  - **유저(명사)** 는 42OAUTH를 통해 **로그인(하나의 값으로 표현가능한 명사)** **한다(동사).**

- 체크인 화면에는 유저의 닉네임과 사진이 보인다.

  - 체크인 화면에는 **유저(명사)** 의 **닉네임(하나의 값으로 표현가능한 명사)** 과 **사진(하나의 값으로 표현가능한 명사)** 이 보인다.

- 유저는 데스크에서 받은 카드 번호를 입력해 각 클러스터에서 체크인 할 수 있다.

  - **유저(명사)** 는 데스크에서 받은 **카드 번호(하나의 값으로 표현 가능한 명사)** 를 이용해 **각 클러스터(하나의 값으로 표현 가능한 명사)** 와이파이 환경에서 **체크인(하나의 값으로 표현 가능한 명사)** **할 수 있다(동사)**.

- 유저는 CLUSTER LOG에서 CLUSTER를 방문한 날짜와 머문 시간을 확인할 수 있다.

  - **유저(명사)** 는 CLUSTER LOG에서 자신이 클러스터를 **방문한 날짜(하나의 값으로 표현 가능한 명사)** 와 **머문 시간(하나의 값으로 표현 가능한 명사)** 을 **확인 할 수 있다.(동사)**

- 유저는 데스크에서 받은 카드를 반납하고 체크아웃 버튼을 누르면 체크아웃할 수 있다.

  - **유저(명사)** 는 데스크에서 받은 카드를 반납하고 **체크아웃(하나의 값으로 표현 가능한 명사)** 버튼을 누르면 **체크아웃 할 수 있다.(동사)**

- OAUTH 토큰이 만료되면 유저는 자동으로 로그아웃 된다.

  - OAUTH 토큰이 만료되면 **유저(명사)** 는 자동으로 **로그아웃(하나의 값으로 표현 가능한 명사)** **된다.(동사)**

## 분석 정리

1. entity(명사) 후보

   - 유저
   - 클러스터 로그

2. attribute(하나의 값으로 표현 가능한 명사) 후보

   - 로그인/로그아웃
   - 닉네임
   - 사진
   - 클러스터 장소(개포, 서초)
   - 클러스터 총 좌석수
   - 클러스터 사용중인 좌석 수
   - 운영시간
   - 카드 번호
   - 체크인/체크아웃
   - 방문한 날짜
   - 머문 시간

3. realtion(동사) 후보

   entity - attribute realation

   - 유저 - 로그인/로그아웃 , 닉네임, 사진, 카드번호, 클러스터 장소, 체크인/체크아웃, 방문한 날짜, 머문 시간

   entity후보와 relation이 없는 속성들

   - 클러스터 총 좌석 수
   - 클러스터 운영 시간

## ERD 생성

![](https://d2sqqdb3t4xrq5.cloudfront.net/upload/uW7r4bniJ7fWHnFPM/M2VKMnRER3pERWM4c3JmRHRfWnBRcGFKZ0ZhQXhwYTdoWm4ucG5n)

- 먼저, entity 후보로 나온 USERS 테이블을 생성하였고 relation관계에 있는 attribute들을 추가하였다.

- 유저 테이블에 기록되는 데이터는 로그인 데이터가 아닌 체크인 데이터이기 때문에 로그인 여부를 알려주는 속성은 필요없다고 판단해 제외했다.

- 방문한 날짜와 머문 시간 역시 체크인 일시와 체크아웃 일시를 바탕으로 계산 가능한 데이터이기 때문에 제외했다.

- 유저 테이블에 묶이지 않는 속성들을 INFO 테이블을 만들어 추가하였다. 이 부분은 기존 DB에서 config 테이블의 용도를 그대로 적용했다.

## 서버 ERD와 실습한 ERD 비교

실제 서버 스키마는 다음과 같다.
![ㄴㅇㄹ](/static/images/blog/42checkin_schema.png)

- 내가 만든 ERD와 비교했을 때 history라는 테이블이 하나 더 있는 것을 알 수 있다. 내부 속성을 보니 user 테이블에 있는 데이터로 구성되어 있다. 사실 이 history 테이블이 왜 따로 존재하는지 아직 이해하지 못함.

- user 테이블에는 데이터 생성, 수정, 삭제 속성이 추가되어 있다. 데이터 보존을 위해 데이터 삭제는 해당 속성 값이 null인지 timestamp값이 들어가있는지에 따라 나뉘어지는 듯하다. 그럼 데이터 삭제는 언제 어떻게 발생하는거지?

- 나는 user를 학생들로만 한정했는데 실 서버 ERD에서 유저는 관리자 타입이 추가로 존재했다.

- 체크아웃은 학생이 직접 하는 것이 아니라 관리자가 카드 수거후 진행하는 것이었다. 서비스를 아직 사용해보지 못해서 시스템이 어떻게 돌아가는지 정확하게 파악하지 못해 서비스 룰을 정확하게 작성하지 못했다.

## 느낀점

데이터 모델링을 할 때는 할 수 있는 만큼 서비스 룰을 자세하게 작성해야 한다. 그래야 필요한 데이터를 빠짐 없이 리스트업 할 수 있고 그 안에서 생성되는 관계도 더 구체적으로 나타나기 때문이다.
