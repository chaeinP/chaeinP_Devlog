---
title: Network_웹 캐시
date: '2021-09-20'
tags: ['NETWORK']
draft: false
summary: 서버에서 웹캐시를 제어하는 방법
---

> 캐시는 데이터나 값을 미리 복사해놓는 임시 장소로 메인 메모리에 접근해서 데이터를 가져오는 시간이 오래걸리거나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다.

## 웹 캐시

사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다.

웹 캐시는 이렇게 작동한다.

- 브라우저는 첫 요청에 대한 응답을 응답헤더의 조건 아래 캐시로 저장한다.
- 브라우저는 요청을 보내기 전 캐시를 우선 조회한다.
- 캐시에 원하는 데이터가 있으면 사용한다.
- 캐시에 해당 데이터가 존재하지 않으면 서버에 데이터를 다시 요청한다.

## Cache-Control

서버는 브라우저가 캐시를 저장할 수 있는 시간을 지정할 수 있다. 응답 헤더에 `Cache-Control` 속성을 통해 캐시가 유효한 시간을 설정한다.

```
Cache-Control : 60
// 60초동안만 저장할 수 있음
```

캐시의 유효 시간이 만료되면 브라우저는 서버에 재요청을 보낸다. 서버는 요청에 맞는 데이터를 전송한다. 만약 데이터가 변경되지 않았다면? 캐시 유효시간이 지나 또 똑같은 데이터를 받아오는건 비효율적이다. 이를 보완하기 위한 다양한 방법이 존재한다.

## 검증헤더와 조건부 요청

### Last Modified와 If-Modified-Since

- 서버의 응답 헤더에 Last Modified를 이용해 캐시의 마지막 수정시간을 함께 보낸다. 브라우저는 캐시를 저장할 때 Last Modified 값도 함께 저장한다.
- 클라이언트는 이후 요청을 보낼때 If-Modified-Since를 이용해 캐시 유효시간이 만료된 데이터의 마지막 수정 시간을 헤더에 실어 보낸다.
- 만약 요청 헤더에 담긴 데이터 수정 시간과 서버의 데이터 수정 시간이 같으면 서버는 304 Not Modified 상태코드와 함께 바디를 제외한 HTTP헤더만 전송한다.
- 브라우저는 캐시 데이터를 다시 받은 응답의 max-age만큼 갱신하고 재사용한다.
- 만약 수정시간이 다르면 서버는 바디에 새로운 데이터를 실어보낸다.

결과적으로 네트워크 요청이 발생하지만 데이터 변동이 없을 경우 용량이 적은 헤더 정보만 응답하므로 효율적이다.

**Last Modified와 If-Modified-Since의 단점**

- 데이터를 수정하였으나 결과적으로 데이터 결과는 수정 전과 똑같은 경우에도 데이터 수정 날짜를 비교하기 때문에 데이터가 재전송된다.
- 서버에서 캐시를 관리할 수가 없다.

### Etag와 If-None-Match

`Etag`는 데이터의 해시 값이다.

- 서버는 리소스 조회 요청이 오면 Etag HTTP 헤더에 유효성 검사 토큰(콘텐츠의 해시값)을 전달한다.
- 브라우저는 데이터와 함께 해당 해시값을 캐시에 저장한다.
- 브라우저 캐시 내 데이터가 만료되면 If-None-Match 헤더에 저장했던 Etag를 서버에 보내 해당 데이터가 변경되었는지 확인한다.
- Etag값이 똑같다면 서버는 이번에도 304 Not Modified 상태코드와 함께 바디없이 헤더에만 동일한 Etag값과 max-age값을 담아 반환한다.
- 만약 다르다면 업데이트 된 리소스와 새로운 Etag값을 반환한다.

서버는 Etag를 이용해 캐시를 제어할 수 있다. 예를 들어 서버는 베타 오픈 기간인 3일 동안 파일이 변경되어도 Etag를 동일하게 유지하다가 애플리케이션 배포 주기에 맞추어 Etag를 갱신할 수 있다.

하지만 Etag 역시 캐시 유효 시간이 만료되어야 데이터를 갱신한다는 문제를 가지고 있다. 서버에 데이터가 변경되어도 실시간으로 클라이어트에 반영되지 않는다는 얘기이다. 만약 실시간으로 데이터가 반영되어야 한다면 수정때마다 파일의 이름을 바꿔주어야 한다. 이 경우 클라이언트는 완전히 새로운 데이터로 인지하고 데이터를 갱신한다.

### 캐시 조건부 요청 헤더

- `Cache-Control : max-age (초단위)` : 캐시의 유효시간을 설정한다.

- `Cache-Control : no-store` : 민감한 정보를 담고 있으므로 사용하고 최대한 빨리 삭제, 저장하면 안된다는 의미

- `Cache-Control : no-cache` : 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용해야한다는 의미

- `Cache-Control : must-revalidate` : 캐시 만료 후 최초 조회시 원서버에 검증해야 함. 원 서버에 접근 실패시 반드시 오류가 발생해야 함(504(Gateway Timeout))

> no-cache와 must-revalidate는 모두 원서버에 검증하고 사용해야한다는 공통점이 있지만 다른점도 있다. no-cache의 경우 원서버에 접근이 불가능할 경우 중간 프록시 서버가 예전 데이터라도 보여주자는 개념으로 200 OK와 함께 캐시 데이터를 반환한다. 그러나 must-revalidate의 경우 원서버에 접근이 불가능할 경우 오류가 발생한다. 데이터 정확도가 높아야하는 요청의 경우에는 must-revalidate를 사용하는 것이 적합하다.

- `Pragma : no-cache` : HTTP 1.0 하위호환

확실한 캐시 무효화를 하고 싶다면 위에 있는 캐시 지시어를 모두 넣어야 한다.

```
Cache-Control : no-cache, no-store, must-revalidate
Pragma : no-cache
```

## 프록시 캐시

> 프록시 서버란 클라이언트와 서버사이에 대리로 통신을 수행하는 서버를 의미한다. 프록시 서버는 보안, 캐싱, 로드 밸랜싱 역할 등을 수행한다.

만약 대한민국에서 요청한 데이터의 원서버가 미국에 있으면 응답을 받는데 많은 시간이 걸릴 수 있다. 이때 한국에 있는 프록시 서버에 수요가 많은 데이터를 캐싱해두면 훨씬 빠른 속도로 데이터를 가져올 수 있다. 브라우저에 저장되는 캐시를 private 캐시라고 한다면 이처럼 프록시 서버에 있는 캐시를 public 캐시 라고 한다.

### 프록시 캐시를 위한 조건부 요청

- `Cache-Control : public` : 응답이 퍼블릭 캐시에 저장되어도 된다는 의미

- `Cache-Control : private` : 응답이 private 캐시에만 저장되어야 한다는 의미

- `Cache-Control : s-maxage` : 프록시 캐시에만 적용되는 max-age

- `Age : 60` : 오리진 서버에서 응답후 프록시 캐시 내에 머문시간(초)
