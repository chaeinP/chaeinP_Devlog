---
title: Deploy_Nginx
date: '2022-02-03'
tags: ['Deploy']
draft: false
summary: 'Nginx를 이용해 배포하기'
---

Munetic 프로젝트는 nginx를 통해 서버를 배포하고 있다. 당시 멘토님께서 https 사용을 위해 nginx를 사용하여야한다는 말을 듣고 nginx를 쓰긴 했는데 nginx에 대한 제대로 이해하지 않고 사용한 것 같아 계속 찜찜했다.이와 관련해 좋은 영상 자료를 찾아 내용을 정리해보려 한다.

> 다음의 내용은 [[10분 테코톡] 🤫 피케이의 Nginx](https://www.youtube.com/watch?v=6FAwAXXj5N0)을 시청하며 기록한 학습 로그입니다.

## apache 와 nginx의 역사

### 1995 apache 등장

아파치가 개발되는 시점에는 이미 유닉스 기반의 최초 웹서버 NCSA HTTPD가 있었다. 이 웹서버는 버그가 많았는데 이 웹서버에서 버그를 수정하고 구조를 변경하고 기능을 추가해 탄생한것이 아파치다. 아파치는 요청 커넥션이 들어오면 새로운 프로세스를 생성하는 구조로 작동한다. 이는 UNIX계열 OS가 네트워크 커넥션을 형성하는 모델을 그대로 본따 만든 것이다. 프로세스를 새로 생성하는 것은 시간이 걸리기 때문에 이를 보완하기 위해 prefork 방식을 사용했다. prefork 방식은 요청이 들어오기 전 미리 프로세스를 만들어두고 요청이 들어오면 각 커넥션에 프로세스를 할당하는 방식으로 동작한다. 만들어놓은 프로세스를 다 사용하면 그 때 새로운 프로세스를 생성한다. 이러한 구조는 개발하기 쉽다는 장점이 있었고 덕분에 개발자들은 필요한 모듈을 만들어 서버에 빠르게 기능을 추가할 수 있게 되었다. 이를 통해 일정부분 동적 콘텐츠도 처리할 수 있게 된다. 또한 확장성이 좋아 응답을 처리하는 과정을 하나의 서버에서 해결하기 용이했다. 이러한 장점으로 아파치는 빠르게 점유율 1위를 달성했다.

### 1999 apache 위기

인터넷 트래픽이 급격히 늘면서 apache의 단점이 드러나기 시작했다. 서버에 동시에 요청이 들어왔을 때 커넥션을 더이상 형성하지 못하는 문제가 발생했는데 이를 C10K 문제 라고 한다. connection 10,000개를 줄인 표현이다. 클라이언트는 한 커넥션을 이용해 여러 요청을 보낼 수 있다. 커넥션은 http 헤더에 있는 keep-alive 설정 만큼 일정 시간동안 유지된다. 한번 커넥션을 생성하면 여러 절차가 필요하기 때문에 매 요청마다 커넥션을 생성하는 것은 비효율적이고 성능에도 큰 영향을 미친다. 따라서 커넥션이 한번 생성되면 커넥션을 일정시간 유지시켜 여러개의 요청을 처리할 수 있도록 한 것이다.

당시 컴퓨터 하드웨어 성능은 이 정도의 요청을 처리할만큼 좋았다. C10K 문제의 진짜 원인은 아파치 서버에 있었다. 아파치 서버는 커넥션이 형성될 때마다 프로세스를 할당하는데 동시에 연결되는 커넥션이 늘어난다는 것은 생성된 프로세스가 많다는 것이고 이는 곧 메모리 부족 현상으로 이어진다. 또한 아파치의 장점으로 여겨졌던 확장성은 그만큼 아파치를 무겁게 만들었고 구조상 컨텍스트 스위칭이 많이 발생할 수 밖에 없어 CPU의 부하도 증가했다.

### 2004 nginx

위에서 제시된 아파치 문제를 보완하기 위해 새로운 구조를 취한 nginx가 개발되었다. 사용 방법은 아파치 서버 앞단에 nginx를 두어 동시 커넥션을 nginx에서 유지할 수 있게 하는 것이다. 또한 nginx는 그 자체로 웹서버이기 때문에 정적 콘텐츠의 경우에는 바로 처리가 가능했고 아파치 서버는 더 복작한 요청을 처리하는데 집중할 수 있게 되었다. nginx가 아파치의 문제점을 해결할 수 있었던 것은 이벤트 처리 구조를 기반으로 동작하기 때문이다.

nginx에는 크게 두가지의 프로세스가 있다. 마스터 프로세스는 설정 파일을 읽고 설정에 맞게 워커프로세스를 생성한다. 이때 워커 프로세스에는 지정된 listen 소켓을 배정받는다. 이 소켓으로 요청을 받아 커넥션을 형성하고 요청을 처리한다. 이 워커프로세스는 커넥션 하나만 담당하지 않는데 만약 하나의 요청 커넥션이 연결되고 요청 처리가 완료된 이후 추가 요청이 없다면 다른 요청 커넥션을 생성하거나 다른 커넥션으로 들어온 요청을 처리한다. 이처럼 nginx는 요청 커넥션 생성, 제거, 처리를 모두 이벤트라고 불리고 이 이벤트들은 OS 커널이 큐형태로 담아 워커 프로세스에게 전달한다. 워커프로세스는 이 이벤트들을 순차적으로 처리해나간다. 이 때문에 커넥션은 유지하면서 놀고있는 프로세스를 가지는 아파치 서버보다 nginx가 더 효율적으로 자원을 처리한다고 볼 수 있다. 만약 이벤트들 중 처리가 오래걸리는 작업이 있다면 nginx는 이러한 이벤트를 스레드 풀이라는 곳에 작업을 넘기고 그 다음 요청들을 처리한다. 이를 통해 요청이 블로킹 되는 상황을 막는다. 보통 이런 워커프로세스는 cpu의 코어 갯수만큼 생성된다.

nginx는 또한 서버 설정을 동적으로 변경할 수도 있다. 개발자가 설정 파일을 수정하면 마스터 프로세스는 해당 워커 프로세스를 추가로 생성하고 기존 프로세스의 경우 더이상 새로운 요청을 받지 않다가 기존 모든 요청 커넥션이 종료되면 해당 프로세스를 종료시킨 뒤 새로 생성된 프로세스를 통해 이벤트를 처리할 수 있게 한다.

nginx는 단점도 존재하는데 이는 개발자가 직접 모듈을 개발하고 추가하기 까다롭다는 것이다. 기존에 돌아가고 있는 워커프로세스를 종료시켜 연결된 커넥션을 모두 삭제시켜버릴 수 있기 때문이다.

### 2008 nginx 부흥

스마트폰이 보급되고 서버가 동시 커넥션으로 유지해야하는 요청의 수가 급격히 늘면서 많은 서비스들이 nginx를 선택하기 시작했다. 아파치 또한 성능 개선을 위해 MPM이라는 모듈을 도입했는데 이는 이전의 prefork방식과 새로 도입된 워커 스레드 처리 방식을 선택할 수 있게 했다. 그러나 동시 커넥션 수 대비 메모리 사용율을 보면 nginx가 현저히 낮다고 한다.

### nginx의 역할

- 로드밸런서
- 웹 서버
- SSL 터미네이션 : 클라이언트와는 https통신을 서버와는 http 통신을 해 서버가 담당해야할 복호화 과정을 nginx가 대신 처리해주어 서버는 비즈니스 로직 처리에 집중할 수 있다. 보통 이경우 nginx는 서버와 같은 네트워크안에 있기 때문에 http통신을 해도 보안상 위험이 적다.
- http 캐싱 : 이 경우는 SSL 터미네이션 기능과는 반대로 서버가 아닌 클라이언트에 가깝게 배치한다. 한번 서버로부터 받은 응답을 보관해 클라이언트에 전달한다.
- HSTS
- CORS
- TCP/UDP 커넥션 부하 분산
- HTTP/2

### 관련 자료

- [현업 nginx 설정 템플릿](https://github.com/h5bp/server-configs-nginx)
- https://hackmag.com/devops/nginx-interview/
- https://aosabook.org/en/nginx.html
- http://kegel.com/c10k.html
